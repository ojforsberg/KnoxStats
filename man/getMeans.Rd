% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getMeans.R
\name{getMeans}
\alias{getMeans}
\title{Calculate Block Means of a Vector}
\usage{
getMeans(x, block_size = 1)
}
\arguments{
\item{x}{A numeric vector to be aggregated.}

\item{block_size}{Number of consecutive elements to average together.
Must be a positive integer less than or equal to the length of \code{x}.}
}
\value{
A numeric vector of block means. The length is \code{floor(length(x)/block_size)}.
}
\description{
Divides a numeric vector into equal-sized blocks and calculates the mean of
each block. This is useful for data aggregation, smoothing, or downsampling.
}
\details{
The function divides the input vector into consecutive blocks of size
\code{block_size}. If the length of \code{x} is not evenly divisible by \code{block_size},
excess elements at the beginning of the vector are discarded to create
complete blocks. This ensures all block means are calculated from the
same number of observations.
}
\examples{
# Basic usage
x <- 1:12
get_means(x, 3)  # Means of [1,2,3], [4,5,6], [7,8,9], [10,11,12]

# Downsample a time series
time_series <- sin(seq(0, 4*pi, length.out = 100))
smoothed <- get_means(time_series, 5)

# Compare with original length
length(time_series)  # 100
length(smoothed)     # 20

# Visualize the effect
plot(time_series, type = "l", col = "gray", 
     main = "Original vs Block-Averaged")
lines(rep(smoothed, each = 5), col = "red", lwd = 2)
legend("topright", legend = c("Original", "Block Mean (size=5)"),
       col = c("gray", "red"), lty = 1)

}
\seealso{
\code{\link{apply}} for applying functions over array margins,
\code{\link{rowMeans}} for alternative matrix row means,
\code{\link{filter}} for moving averages and other smoothing operations
}
